<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>[译] RxJS: 理解 publish 和 share 操作符 | Rxjs</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="目录">
    <link rel="preload" href="/assets/css/0.styles.ccac5a78.css" as="style"><link rel="preload" href="/assets/js/app.de24a261.js" as="script"><link rel="preload" href="/assets/js/2.f6e3d3ee.js" as="script"><link rel="preload" href="/assets/js/20.ca0fdbb6.js" as="script"><link rel="prefetch" href="/assets/js/10.157238cf.js"><link rel="prefetch" href="/assets/js/11.41a012c6.js"><link rel="prefetch" href="/assets/js/12.b8086885.js"><link rel="prefetch" href="/assets/js/13.e45c7342.js"><link rel="prefetch" href="/assets/js/14.e3e54685.js"><link rel="prefetch" href="/assets/js/15.9351c89b.js"><link rel="prefetch" href="/assets/js/16.7d3aff72.js"><link rel="prefetch" href="/assets/js/17.cd3a7c14.js"><link rel="prefetch" href="/assets/js/18.7b5bc8d2.js"><link rel="prefetch" href="/assets/js/19.77700336.js"><link rel="prefetch" href="/assets/js/21.d6bc78c5.js"><link rel="prefetch" href="/assets/js/22.2428074e.js"><link rel="prefetch" href="/assets/js/23.93a777ed.js"><link rel="prefetch" href="/assets/js/24.73aa7224.js"><link rel="prefetch" href="/assets/js/25.e43f6412.js"><link rel="prefetch" href="/assets/js/26.60ae3da3.js"><link rel="prefetch" href="/assets/js/27.03e00c07.js"><link rel="prefetch" href="/assets/js/28.95c8c079.js"><link rel="prefetch" href="/assets/js/29.eb8ac4a8.js"><link rel="prefetch" href="/assets/js/3.d907f710.js"><link rel="prefetch" href="/assets/js/30.5c09e00d.js"><link rel="prefetch" href="/assets/js/31.962a908d.js"><link rel="prefetch" href="/assets/js/32.c0fe7bdd.js"><link rel="prefetch" href="/assets/js/33.74f04d2b.js"><link rel="prefetch" href="/assets/js/34.20bdc3d5.js"><link rel="prefetch" href="/assets/js/35.d30ab2c2.js"><link rel="prefetch" href="/assets/js/36.d13995e1.js"><link rel="prefetch" href="/assets/js/37.08e1d965.js"><link rel="prefetch" href="/assets/js/38.fae351d3.js"><link rel="prefetch" href="/assets/js/39.a40c9688.js"><link rel="prefetch" href="/assets/js/4.fe9ea34b.js"><link rel="prefetch" href="/assets/js/40.87c8b8ee.js"><link rel="prefetch" href="/assets/js/41.242cc580.js"><link rel="prefetch" href="/assets/js/42.736834a5.js"><link rel="prefetch" href="/assets/js/43.57a7a89e.js"><link rel="prefetch" href="/assets/js/44.2c085c54.js"><link rel="prefetch" href="/assets/js/45.fcfe6221.js"><link rel="prefetch" href="/assets/js/46.31dda88a.js"><link rel="prefetch" href="/assets/js/5.7bdab572.js"><link rel="prefetch" href="/assets/js/6.af184b79.js"><link rel="prefetch" href="/assets/js/7.d5eaab60.js"><link rel="prefetch" href="/assets/js/8.b99143ac.js"><link rel="prefetch" href="/assets/js/9.55a51475.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ccac5a78.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Rxjs</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/rxjs-docs/home.html" class="nav-link">
  rxjs
</a></div><div class="nav-item"><a href="/articles/home.html" class="nav-link">
  精选文章
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/rxjs-docs/home.html" class="nav-link">
  rxjs
</a></div><div class="nav-item"><a href="/articles/home.html" class="nav-link">
  精选文章
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/articles/home.html" class="sidebar-link">RxJS 优质文章翻译</a></li><li><a href="/articles/articles/ADVANCED-CACHING-WITH-RXJS.html" class="sidebar-link">[译] RxJS 高级缓存</a></li><li><a href="/articles/articles/Angular-Simple-Infinite-Scroller-Directive-With-RxJS-Observables.html" class="sidebar-link">[译] Angular: 使用 RxJS Observables 来实现简易版的无限滚动加载指令</a></li><li><a href="/articles/articles/Debugging-RxJS-Part1-Tooling.html" class="sidebar-link">[译] 调试 RxJS 第1部分: 工具篇</a></li><li><a href="/articles/articles/Debugging-RxJS-Part2-Logging.html" class="sidebar-link">[译] 调试 RxJS 第2部分: 日志篇</a></li><li><a href="/articles/articles/Don't-Unsubscribe.html" class="sidebar-link">[译] RxJS: 别取消订阅</a></li><li><a href="/articles/articles/Hot-Vs-Cold-Observables.html" class="sidebar-link">[译] 热的 Vs 冷的 Observables</a></li><li><a href="/articles/articles/How-To-Use-RefCount.html" class="sidebar-link">[译] RxJS: 如何使用 refCount</a></li><li><a href="/articles/articles/Infinite-Scroll-In-Angular-An-RxJS.html" class="sidebar-link">[译] 使用 Angular 和 RxJS 实现的无限滚动加载</a></li><li><a href="/articles/articles/Learn-To-Combine-RxJS-Sequences-With-Super-Intuitive-Interactive-Diagrams.html" class="sidebar-link">[译] RxJS: 使用超直观的交互图来学习组合操作符</a></li><li><a href="/articles/articles/Learning-Observable-By-Building-Observable.html" class="sidebar-link">[译] 通过构建 Observable 来学习 Observable</a></li><li><a href="/articles/articles/Naive-Infinite-Scroll-In-Reactive-Programming-Using-RxJS-Observables.html" class="sidebar-link">[译] 使用响应式编程来实现简易版的无限滚动加载</a></li><li><a href="/articles/articles/On-The-Subject-Of-Subjects.html" class="sidebar-link">[译] 关于 RxJS 中的 Subject</a></li><li><a href="/articles/articles/PRIMER-ON-RXJS-SCHEDULERS.html" class="sidebar-link">[译] RxJS 调度器入门</a></li><li><a href="/articles/articles/Reactive-Brain-Waves.html" class="sidebar-link">[译] 响应式脑电波</a></li><li><a href="/articles/articles/RxJS-Observable-Interop-With-Promises-And-Async-Await.html" class="sidebar-link">[译] RxJS Observable 与 Promises 和 Async-Await 交互</a></li><li><a href="/articles/articles/Six-Operators-That-You-Must-Know.html" class="sidebar-link">[译] RxJS: 6个你必须知道的操作符</a></li><li><a href="/articles/articles/Subjects-For-Human-Beings.html" class="sidebar-link">[译] RxJS: 白话 Subjects</a></li><li><a href="/articles/articles/TAMING-SNAKES-WITH-REACTIVE-STREAMS.html" class="sidebar-link">[译] RxJS 游戏之贪吃蛇</a></li><li><a href="/articles/articles/Testing-Race-Conditions-Using-RxJS-Marbles.html" class="sidebar-link">[译] RxJS 进阶技巧: 使用 RxJS Marbles 测试竞争条件</a></li><li><a href="/articles/articles/Understanding-Subjects-in-RxJS.html" class="sidebar-link">[译] 理解 RxJS 中 Subjects</a></li><li><a href="/articles/articles/Understanding-The-Publish-And-Share-Operators.html" aria-current="page" class="active sidebar-link">[译] RxJS: 理解 publish 和 share 操作符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/articles/articles/Understanding-The-Publish-And-Share-Operators.html#多播的心智模型" class="sidebar-link">多播的心智模型</a></li><li class="sidebar-sub-header"><a href="/articles/articles/Understanding-The-Publish-And-Share-Operators.html#multicast-操作符和-connectableobservable" class="sidebar-link">multicast 操作符和 ConnectableObservable</a></li><li class="sidebar-sub-header"><a href="/articles/articles/Understanding-The-Publish-And-Share-Operators.html#publish-操作符" class="sidebar-link">publish 操作符</a></li><li class="sidebar-sub-header"><a href="/articles/articles/Understanding-The-Publish-And-Share-Operators.html#特殊类型的-subjects" class="sidebar-link">特殊类型的 subjects</a></li><li class="sidebar-sub-header"><a href="/articles/articles/Understanding-The-Publish-And-Share-Operators.html#share-操作符" class="sidebar-link">share 操作符</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="译-rxjs-理解-publish-和-share-操作符"><a href="#译-rxjs-理解-publish-和-share-操作符" class="header-anchor">#</a> [译] RxJS: 理解 publish 和 share 操作符</h1> <blockquote><p>原文链接: <a href="https://blog.angularindepth.com/rxjs-understanding-the-publish-and-share-operators-16ea2f446635" target="_blank" rel="noopener noreferrer">https://blog.angularindepth.com/rxjs-understanding-the-publish-and-share-operators-16ea2f446635<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p><img src="/assets/img/header.2fc109ef.jpeg" alt="Cover"></p> <p>照片取自 <a href="https://unsplash.com/" target="_blank" rel="noopener noreferrer">Unsplash<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，作者 <a href="https://unsplash.com/photos/lUaaKCUANVI" target="_blank" rel="noopener noreferrer">Kimberly Farmer<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p> <p>我经常会被问及 <code>publish</code> 操作符的相关问题:</p> <blockquote><p>publish 和 share 之间的区别是什么？</p> <p>如何导入 refCount 操作符？</p> <p>何时使用 AsyncSubject？</p></blockquote> <p>我们来解答这些问题，并让你了解到更多内容，首先从基础入手。</p> <h2 id="多播的心智模型"><a href="#多播的心智模型" class="header-anchor">#</a> 多播的心智模型</h2> <p>多播是一个术语，它用来描述由单个 observable 发出的每个通知会被多个观察者所接收的情况。一个 observable 是否具备多播的能力取决于它是热的还是冷的。</p> <p>热的和冷的 observable 的特征在于 observable 通知的生产者是在哪创建的。在 Ben Lesh 的 <a href="/articles/articles/Hot-Vs-Cold-Observables.html">热的 Vs 冷的 Observables</a> 一文中，他详细讨论了两者间的差异，这些差异可以归纳如下:</p> <ul><li>如果通知的生产者是观察者订阅 observable 时创建的，那么 observable 就是冷的。例如，<a href="http://cn.rx.js.org/class/es6/Observable.js~Observable.html#static-method-timer" target="_blank" rel="noopener noreferrer"><code>timer</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> observable 就是冷的，每次订阅时都会创建一个新的定时器。</li> <li>如果通知的生产者不是每次观察者订阅 observable 时创建的，那么 observable 就是热的。例如，使用 <a href="http://cn.rx.js.org/class/es6/Observable.js~Observable.html#static-method-fromEvent" target="_blank" rel="noopener noreferrer"><code>fromEvent</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 创建的 observable 就是热的，产生事件的元素存在于 DOM 之中，它不是观察者订阅时所创建的。</li></ul> <p>冷的 observables 是单播的，每个观察者所接收到的通知都是来自不同的生产者，生产者是观察者订阅时所创建的。</p> <p>热的 observables 是多播的，每个观察者所接收到的通知都是来自同一个生产者。</p> <p>有些时候，需要冷的 observable 具有多播的行为，RxJS 引入了 <code>Subject</code> 类使之成为可能。</p> <p>Subject 即是 observable，又是 observer (观察者)。通过使用观察者来订阅 subject，然后 subject 再订阅冷的 observable，可以让冷的 observable 变成热的。这是 RxJS 引入 subjects 的主要用途，在 Ben Lesh 的 <a href="/articles/articles/On-The-Subject-Of-Subjects.html">关于 RxJS 中的 Subject</a> 一文中，他指出:</p> <blockquote><p><strong>多播是 RxJS 中 Subjects 的主要用法。</strong></p></blockquote> <p>我们来看下面的示例:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;rxjs/Observable&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Subject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;rxjs/Subject&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;rxjs/add/observable/defer&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;rxjs/add/observable/of&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> source <span class="token operator">=</span> Observable<span class="token punctuation">.</span><span class="token function">defer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Observable<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>
  Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">observer</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">observer </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function-variable function">complete</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">observer </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: complete</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subject<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
subject<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
subject<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
source<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>示例中的 <code>source</code> 是冷的。每次观察者订阅 <code>source</code> 时，传给 <a href="http://cn.rx.js.rog/class/es6/Observable.js~Observable.html#static-method-defer" target="_blank" rel="noopener noreferrer"><code>defer</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的工厂函数会创建一个发出随机数后完成的 observable 。</p> <p>要让 <code>source</code> 变成多播的，需要观察者订阅 subject，然后 subject 再订阅 <code>source</code> 。<code>source</code> 只会看到一个订阅 ( subscription )，它也只生成一个包含随机数的 <code>next</code> 通知和一个 <code>complete</code> 通知。Subject 会将这些通知发送给它的观察者，输出如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>observer a: 42
observer b: 42
observer a: complete
observer b: complete
</code></pre></div><p>此示例可以作为 RxJS 多播的基本心智模型: 一个源 observable，一个订阅源 observable 的 subject 和多个订阅 subject 的观察者。</p> <h2 id="multicast-操作符和-connectableobservable"><a href="#multicast-操作符和-connectableobservable" class="header-anchor">#</a> multicast 操作符和 ConnectableObservable</h2> <p>RxJS 引入了 <a href="http://cn.rx.js.org/class/es6/Observable.js~Observable.html#instance-method-multicast" target="_blank" rel="noopener noreferrer"><code>multicast</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 操作符，它可以应用于 observable ，使其变成热的。此操作符封装了 subject 用于多播 observable 时所涉及的基础结构。</p> <p>在看 <code>multicast</code> 操作符之前，我们使用一个简单实现的 <code>multicast</code> 函数来替代上面示例中的 subject :</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">multicast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>source<span class="token operator">:</span> Observable<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subject<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  source<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> subject<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token function">multicast</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>代码改变后，示例的输出如下:</p> <div class="language- extra-class"><pre class="language-text"><code>observer a: complete
observer b: complete
</code></pre></div><p>这并不是我们想要的结果。在函数内部订阅 subject 使得 subject 在被观察者订阅之前就已经收到了 <code>next</code> 和 <code>complete</code> 通知，所以观察者只能收到 <code>complete</code> 通知。</p> <p>这是可避免的，任何连接多播基础结构的函数的调用者需要能够在 subject 订阅源 observable 时进行控制。RxJS 的 <code>multicast</code> 操作符通过返回一个特殊的 observable 类型 <a href="http://cn.rx.js.org/class/es6/observable/ConnectableObservable.js~ConnectableObservable.html" target="_blank" rel="noopener noreferrer">ConnectableObservable<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来实现的。</p> <p>ConnectableObservable 封装了多播的基础结构，但它不会立即订阅源 observable ，只有当它的 <code>connect</code> 方法调用时，它才会订阅源 observable 。</p> <p>我们来使用 <code>multicast</code> 操作符:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;rxjs/Observable&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Subject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;rxjs/Subject&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;rxjs/add/observable/defer&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;rxjs/add/observable/of&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;rxjs/add/operator/multicast&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> source <span class="token operator">=</span> Observable<span class="token punctuation">.</span><span class="token function">defer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Observable<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>
  Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">observer</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">observer </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function-variable function">complete</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">observer </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: complete</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> m <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">multicast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Subject<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>代码改变后，现在观察者可以收到 <code>next</code> 通知了:</p> <div class="language- extra-class"><pre class="language-text"><code>observer a: 54
observer b: 54
observer a: complete
observer b: complete
</code></pre></div><p>调用 <code>connect</code> 时，传入 <code>multicast</code> 操作符的 subject 会订阅源 observable，而 subject 的观察者会收到多播通知，这正符合 RxJS 多播的基本心智模型。</p> <p>ConnectableObservable 还有另外一个方法 <code>refCount</code>，它可以用来确定源 observable 何时产生了订阅。</p> <p><code>refCount</code> 看上去就像是操作符，也就是说，它是在 observable 上调用的方法并且返回另一个 observable，但是它只是 <code>ConnectableObservable</code> 的方法而且不需要导入。顾名思义，<code>refCount</code> 返回 observable， 它负责维护已产生的订阅的引用计数。</p> <p>当观察者订阅负责引用计数的 observable 时，引用计数会增加，如果前一个引用计数为0的话，负责多播基础结构的 subject 会订阅源 observable 。当观察者取消订阅时，引用计数会减少，如果引用计数归零的话，subject 会取消对源 observable 的订阅。</p> <p>我们来使用 <code>refCount</code> :</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> m <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">multicast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Subject<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">refCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>代码改变后，输出如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>observer a: 42
observer a: complete
observer b: complete
</code></pre></div><p>只有第一个观察者收到了 <code>next</code> 通知。我们来看看原因。</p> <p>示例中的源 observable 会立即发出通知。也就是说，一旦订阅了，源 observable 就会发出 <code>next</code> 和 <code>complete</code> 通知，<code>complete</code> 通知导致在第二个观察者订阅之前第一个就取消了订阅。当第一个取消订阅时，引用计数会归零，所以负责多播基础结构的 subject 也会取消源 observable 的订阅。</p> <p>当第二个观察者订阅时，subject 会再次订阅源 observable，但由于 subject 已经收到了 <code>complete</code> 通知，所以它无法被重用。</p> <p>向 <code>multicast</code> 传入 subject 的工厂函数可以解决此问题:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> m <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">multicast</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Subject<span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">refCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>代码改变后，每次源 observable 被订阅时，都会创建一个新的 subject，输出如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>observer a: 42
observer a: complete
observer b: 54
observer b: complete
</code></pre></div><p>因为源 observable 会立即发出通知，所以观察者收到的通知是分开的。将 <code>source</code> 进行修改，以便延迟通知:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;rxjs/Observable&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Subject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;rxjs/Subject&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;rxjs/add/observable/defer&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;rxjs/add/observable/of&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;rxjs/add/operator/delay&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;rxjs/add/operator/multicast&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> source <span class="token operator">=</span> Observable<span class="token punctuation">.</span><span class="token function">defer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Observable<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>
  Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>观察者依然会收到多播通知，输出如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>observer a: 42
observer b: 42
observer a: complete
observer b: complete
</code></pre></div><p>总结一下，上述示例展示了 <code>multicast</code> 操作符的以下特点:</p> <ul><li>封装了多播的基础结构以符合多播的心智模型；</li> <li>提供了 <code>connect</code> 方法以用于确定源 observable 何时产生了订阅；</li> <li>提供了 <code>refCount</code> 方法以用于自动管理源 observable 的订阅；</li> <li>如果使用 <code>refCount</code>，必须传入 <code>Subject</code> 的工厂函数，而不是 <code>Subject</code> 实例；</li></ul> <p>接下来我们来看 <code>publish</code> 和 <code>share</code> 操作符，以及 <code>publish</code> 的变种，看看它们是如何在 <code>multicast</code> 操作符所提供的基础之上建立的。</p> <h2 id="publish-操作符"><a href="#publish-操作符" class="header-anchor">#</a> publish 操作符</h2> <p>我们通过下面的示例来看看 <code>publish</code> 操作符:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;rxjs/Observable&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;rxjs/add/observable/defer&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;rxjs/add/observable/of&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;rxjs/add/operator/delay&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">&quot;rxjs/add/operator/publish&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> source <span class="token operator">=</span> Observable<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>
  Observable<span class="token punctuation">.</span><span class="token function">defer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Observable<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  Observable<span class="token punctuation">.</span><span class="token function">defer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Observable<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">observer</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">observer </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function-variable function">complete</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">observer </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: complete</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> p <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>示例中的源 observable 会立即发出一个随机数，经过短暂的延迟后发出另一个随机数，然后完成。这个示例可以让我们看到订阅者在 <code>connect</code> 调用前、<code>connect</code> 调用后以及调用过 publish 的 observable 完成后订阅分别会发生什么。</p> <p><strong><code>publish</code> 操作符是对 <code>multicast</code> 操作符进行了一层薄薄的封装。它会调用 <code>multicast</code> 并传入 <code>Subject</code> 。</strong></p> <p>示例的输出如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>observer a: 42
observer a: 54
observer b: 54
observer a: complete
observer b: complete
observer c: complete
</code></pre></div><p>观察者收到的通知可归纳如下:</p> <ul><li><code>a</code> 是在 <code>connect</code> 调用前订阅的，所以它能收到两个 <code>next</code> 通知和 <code>complete</code> 通知。</li> <li><code>b</code> 是在 <code>connect</code> 调用后订阅的，此时第一个立即发送的 <code>next</code> 通知已经发出过了，所以它只能收到第二个 <code>next</code> 通知和 <code>complete</code> 通知。</li> <li><code>c</code> 是在源 observable 完成后订阅的，所以它只能收到 <code>complete</code> 通知。</li></ul> <p>使用 <code>refCount</code> 来代替 <code>connect</code>:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> p <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">refCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>示例的输出如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>observer a: 42
observer a: 54
observer b: 54
observer a: complete
observer b: complete
observer c: complete
</code></pre></div><p>输出跟使用 <code>connect</code> 时的类似。这是为什么？</p> <p><code>b</code> 没有收到第一个 <code>next</code> 通知是因为源 observable 的第一个 <code>next</code> 通知是立即发出的，所以只有 <code>a</code> 能收到。</p> <p><code>c</code> 是在调用过 publish 的 observable 完成后订阅的，所以订阅的引用计数已经是0，此时将会再生成一个订阅。但是，<code>publish</code> 传给 <code>multicast</code> 的是 subject，而不是工厂函数，因为 subjects 无法被复用，所以 <code>c</code> 只能收到 <code>complete</code> 通知。</p> <p><code>publish</code> 和 <code>multicast</code> 操作符都接受一个可选的 <code>selector</code> 函数，如果指定了此函数，操作符的行为将会有很大的不同。这将在另一篇文章 <a href="/articles/articles/The-Secret-Of-Multicast.html">multicast 操作符的秘密</a>中详细介绍。</p> <h2 id="特殊类型的-subjects"><a href="#特殊类型的-subjects" class="header-anchor">#</a> 特殊类型的 subjects</h2> <p><code>publish</code> 操作符有几个变种，它们都以一种类似的方式对 <code>multicast</code> 进行了包装，传入的是 subjects，而不是工厂函数。但是，它们传入的是不同类型的 subjects 。</p> <p><code>publish</code> 变种使用的特殊类型的 subjects 包括:</p> <ul><li><code>BehaviorSubject</code></li> <li><code>ReplaySubject</code></li> <li><code>AsyncSubject</code></li></ul> <p>关于如何使用这些特殊类型的 subjects 的答案是: 每个变种都与一个特殊类型的 subject 相关联，当你需要的行为类似于某个 <code>publish</code> 变种时，就使用相对应的 subject 。我们来看看这些变种的行为是怎样的。</p> <h3 id="publishbehavior-操作符"><a href="#publishbehavior-操作符" class="header-anchor">#</a> publishBehavior 操作符</h3> <p><code>publishBehavior</code> 传给 <code>multicast</code> 的是 <code>BehaviorSubject</code>，而不是 <code>Subject</code> 。<code>BehaviorSubject</code> 类似于 <code>Subject</code>，但如果 subject 的订阅发生在源 observable 发出 <code>next</code> 通知之前，那么 subject 会发出包含初始值的 <code>next</code> 通知。</p> <p>我们更改下示例，给生成随机数的源 observable 加上短暂的延迟，这样它就不会立即发出随机数:</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> delayed <span class="token operator">=</span> Observable<span class="token punctuation">.</span><span class="token function">timer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">switchMapTo</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> delayed<span class="token punctuation">.</span><span class="token function">publishBehavior</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>示例的输出如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>observer a: -1
observer b: -1
observer a: 42
observer b: 42
observer a: 54
observer b: 54
observer a: complete
observer b: complete
observer c: complete
</code></pre></div><p>观察者收到的通知可归纳如下:</p> <ul><li><code>a</code> 是在 <code>connect</code> 调用前订阅的，所以它能收到带有 subject 的初始值的 <code>next</code> 通知、源 observable 的两个 <code>next</code> 通知和 <code>complete</code> 通知。</li> <li><code>b</code> 是在 <code>connect</code> 调用后但在 subject 收到源 observable 的第一个 <code>next</code> 通知前订阅的，所以它能收到带有 subject 的初始值的 <code>next</code> 通知、源 observable 的两个 <code>next</code> 通知和 <code>complete</code> 通知。</li> <li><code>c</code> 是在源 observable 完成后订阅的，所以它只能收到 <code>complete</code> 通知。</li></ul> <h3 id="publishreplay-操作符"><a href="#publishreplay-操作符" class="header-anchor">#</a> publishReplay 操作符</h3> <p><code>publishReplay</code> 传给 <code>multicast</code> 的是 <code>ReplaySubject</code>，而不是 <code>Subject</code> 。顾名思义，每当观察者订阅时，<code>ReplaySubject</code> 会重放指定数量的 <code>next</code> 通知。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> p <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">publishReplay</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>使用了 <code>publishReplay</code>，示例的输出如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>observer a: 42
observer b: 42
observer a: 54
observer b: 54
observer a: complete
observer b: complete
observer c: 54
observer c: complete
</code></pre></div><p>观察者收到的通知可归纳如下:</p> <ul><li><code>a</code> 是在 <code>connect</code> 调用前订阅的，此时 subject 还没有收到 <code>next</code> 通知，所以 <code>a</code> 能收到源 observable 的两个 <code>next</code> 通知和 <code>complete</code> 通知。</li> <li><code>b</code> 是在 <code>connect</code> 调用后订阅的，此时 subject 已经收到了源 observable 的第一个 <code>next</code> 通知，所以 <code>b</code> 能收到重放的 <code>next</code> 通知、源 observable 的第二个 <code>next</code> 通知和 <code>complete</code> 通知。</li> <li><code>c</code> 是在源 observable 完成后订阅的，所以它能收到重放的 <code>next</code> 通知和 <code>complete</code> 通知。</li></ul> <p>来看看 <code>c</code> 的行为，很明显，不同于 <code>publish</code> 操作符，<code>publishReplay</code> 操作符适合使用 <code>refCount</code> 方法，因为观察者在源 observable 完成后订阅依然能收到任意数量的重放的 <code>next</code> 通知。</p> <h3 id="publishlast-操作符"><a href="#publishlast-操作符" class="header-anchor">#</a> publishLast 操作符</h3> <p><code>publishLast</code> 传给 <code>multicast</code> 的是 <code>AsyncSubject</code>，而不是 <code>Subject</code> 。<code>AsyncSubject</code> 是最特别的特殊类型 subjects 。只有当它完成时，才会发出 <code>next</code> 通知 (如果有 <code>next</code> 通知的话) 和 <code>complete</code> 通知，这个 <code>next</code> 通知是源 observable 中的最后一个 <code>next</code> 通知。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> p <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">publishLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> p<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>使用了 <code>publishLast</code>，示例的输出如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>observer a: 54
observer b: 54
observer a: complete
observer b: complete
observer c: 54
observer c: complete
</code></pre></div><p>观察者收到的通知可归纳如下:</p> <ul><li><code>a</code> 和 <code>b</code> 都是在源 observable 完成前订阅的，但直到源 observable 完成它们才能收到通知，它们能收到带有第二个随机数的 <code>next</code> 通知和 <code>complete</code> 通知。</li> <li><code>c</code> 是在源 observable 完成后订阅的，它能收到带有第二个随机数的 <code>next</code> 通知和 <code>complete</code> 通知。</li></ul> <p>与 <code>publishReplay</code> 类似，<code>publishLast</code> 操作符适合使用 <code>refCount</code> 方法，因为观察者在源 observable 完成后订阅依然能收到任意数量的重放的 <code>next</code> 通知。</p> <h2 id="share-操作符"><a href="#share-操作符" class="header-anchor">#</a> share 操作符</h2> <p><code>share</code> 操作符类似于使用 <code>publish().refCount()</code> 。但是，<code>share</code> 传给 <code>multicast</code> 的是工厂函数，这意味着在引用计数为0之后发生订阅的话，会创建一个新的 <code>Subject</code> 来订阅源 observable 。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">const</span> s <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> s<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token function">observer</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>使用了 <code>share</code>，示例的输出如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>observer a: 42
observer a: 54
observer b: 54
observer a: complete
observer b: complete
observer c: 6
observer c: 9
observer c: complete
</code></pre></div><p>观察者收到的通知可归纳如下:</p> <ul><li><code>a</code> 订阅后立即收到第一个 <code>next</code> 通知，随后是第二个 <code>next</code> 通知和 <code>complete</code> 通知。</li> <li><code>b</code> 只能收到第二个 <code>next</code> 通知和 <code>complete</code> 通知。</li> <li><code>c</code> 是在源 observable 完成后订阅的，会创建一个新的 subject 来订阅源 observable，它会立即收到第一个 <code>next</code> 通知，随后是第二个 <code>next</code> 通知和 <code>complete</code> 通知。</li></ul> <p>在上面这些示例中，我们介绍了 <code>publish</code> 和 <code>share</code> 操作符，当源 observable 完成时，<code>a</code> 和 <code>b</code> 会自动取消订阅。如果源 observable 报错，它们也同样会自动取消订阅。<code>publish</code> 和 <code>share</code> 操作符还有另外一个不同点:</p> <ul><li>如果源 observable 报错，由 <code>publish</code> 返回的 observable 的任何将来的订阅者都将收到 <code>error</code> 通知。</li> <li>但是，由 <code>share</code> 返回的 observable 的任何将来的订阅者会生成源 observable 的一个新订阅，因为错误会自动取消任何订阅者的订阅，将其引用计数归零。</li></ul> <p>就这样了，本文到此结束。我们介绍了六个操作符，但它们全是通过一种类似的方式来实现的，它们全都符合同一个基本的心智模型: 一个源 observable、一个订阅源 observable 的 subject 和多个订阅 subject 的观察者。</p> <p>本文只是简略地介绍了 <code>refCount</code> 方法。想要深入了解，请参见 <a href="/articles/articles/How-To-Use-RefCount.html">RxJS: 如何使用 refCount</a>。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/articles/articles/Understanding-Subjects-in-RxJS.html" class="prev">
        [译] 理解 RxJS 中 Subjects
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.de24a261.js" defer></script><script src="/assets/js/2.f6e3d3ee.js" defer></script><script src="/assets/js/20.ca0fdbb6.js" defer></script>
  </body>
</html>
